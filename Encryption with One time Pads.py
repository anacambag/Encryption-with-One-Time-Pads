
# Name: Ana Camba Gomes


import random


class Message(object):
    def __init__(self, input_text):
        '''
        Initializes a Message object

        input_text (string): the message's text

        a Message object has one attribute:
            the message text
        '''
        self.text = input_text #initializing a message object

    def __repr__(self):
        '''
        Returns a human readable representation of the object
        DO NOT CHANGE

        Returns: (string) A representation of the object
        '''
        return f'''Message('{self.get_text()}')'''

    def get_text(self):
        '''
        Used to access the message text outside of the class

        Returns: (string) the message text
        '''
        return self.text #message text

    def shift_char(self, char, shift):
        '''
        Used to shift a character as described in the pset handout

        char (string): the single character to shift.
                    ASCII value in the range: 32<=ord(char)<=126
        shift (int): the amount to shift char by

        Returns: (string) the shifted character with ASCII value in the range [32, 126]
        '''
        
        
        order_shift = ord(char) + shift - 32# ASCII value (ord) + the number that has to be shifted
        offset = order_shift % 95 # 127 - 32 (it is the number when it passes 126 so it stars counting from 32)
        return chr(offset + 32)
        

    def apply_pad(self, pad):
        '''
        Used to calculate the ciphertext produced by applying a one time pad to the message text.
        For each character in the text at index i shift that character by
            the amount specified by pad[i]

        pad (list of ints): a list of integers used to encrypt the message text
                        len(pad) == len(the message text)

        Returns: (string) The ciphertext produced using the one time pad
        '''
        cyphertext = ''
       
        for char in range(len(pad)): # char will go as many times as the length of our list pad [index]
           cyphertext += self.shift_char(self.get_text()[char],pad[char]) #we evaluate each characters in our string within our previous function created
        
        return cyphertext 
          


class PlaintextMessage(Message):
    def __init__(self, input_text, pad=None):
        '''
        Initializes a PlaintextMessage object.

        input_text (string): the message's text
        pad (list of ints OR None): the pad to encrypt the input_text or None if left empty
            if pad is not None then len(pad) == len(self.input_text)

        A PlaintextMessage object inherits from Message. It has three attributes:
            the message text
            the pad (list of integers, determined by pad
                or generated randomly using self.generate_pad() if pad is None)
            the ciphertext (string, input_text encrypted using the pad)
        '''
        Message.__init__(self,input_text) #using Message Class methods already used
        
        if pad == None: 
            self.pad = self.generate_pad() #if we do not have a pad we use the function generate_pad and that is what we equal our pad to
            self.cyphertext = self.apply_pad(self.pad) #to get our cyphertext we use our apply pad function
        else:
            self.pad = [elt for elt in pad] # creates a copy of our pad
            self.cyphertext = self.apply_pad(self.pad) # we apply that copy pad to our apply_pad function
        

    def __repr__(self):
        '''
        Returns a human readable representation of the object
        DO NOT CHANGE

        Returns: (string) A representation of the object
        '''
        return f'''PlaintextMessage('{self.get_text()}', {self.get_pad()})'''

    def generate_pad(self):
        '''
        Generates a one time pad which can be used to encrypt the message text.

        The pad should be generated by making a new list and for each character
            in the message chosing a random number in the range [0, 110) and
            adding that number to the list.

        Returns: (list of integers) the new one time pad
        '''
        
        new_pad = [] #new list for one time pad 
        
        for char in range(len(self.get_text())):
            random_num = random.randint(0,109) # 109 instead of 110 because is not inclusive
            new_pad.append(random_num) #random number between 0 and 109 to be added to create new pad. Accumulate to create a list of pad.
        return new_pad 

    def get_pad(self):
        '''
        Used to safely access your one time pad outside of the class

        Returns: (list of integers) a COPY of your pad
        '''
        return self.pad.copy() #copy of our pad

    def get_ciphertext(self):
        '''
        Used to access the ciphertext produced by applying pad to the message text

        Returns: (string) the ciphertext
        '''
        
        Cipher = self.apply_pad(self.pad) #we access our ciphertext and return it as a string
        return str(Cipher)

    def change_pad(self, new_pad):
        '''
        Changes the pad used to encrypt the message text and updates any other
        attributes that are determined by the pad.

        new_pad (list of ints): the new one time pad that should be associated with this message.
            len(new_pad) == len(the message text)

        Returns: nothing
        '''
        self.pad = new_pad #changes our pad with a new pad given 
        self.cyphertext = self.apply_pad(new_pad) #update our ciphertext with the new_pad


class EncryptedMessage(Message):
    def __init__(self, input_text):
        '''
        Initializes an EncryptedMessage object

        input_text (string): the ciphertext of the message

        an EncryptedMessage object inherits from Message. It has one attribute:
            the message text (ciphertext)
        '''
        super().__init__(input_text) #allows use to use main class methods
        self.Encrypted_Message = input_text #initializing an EncryptedMessage object which is the input_text

    def __repr__(self):
        '''
        Returns a human readable representation of the object
        DO NOT CHANGE

        Returns: (string) A representation of the object
        '''
        return f'''EncryptedMessage('{self.get_text()}')'''

    def decrypt_message(self, pad):
        '''
        Decrypts the message text that was encrypted with pad as described in the writeup

        pad (list of ints): the new one time pad used to encrypt the message.
            len(pad) == len(the message text)

        Returns: (PlaintextMessage) the decrypted message (containing the pad)
        '''
        new_pad  = [] #creates a new list
        
        for char in pad: #for every item of the pad
            new_pad.append(-char) #add every item in reverse order to decrypt in my new list
            #if we shifted a character by +x to encrypt it then to decrypt it we simply shift it back by -x
        
        
        cyphertext_variable = self.apply_pad(new_pad) #initialize cyphertext_variable as the cyphertext returned by applying the function apply_pad to our new list
        
        return PlaintextMessage(cyphertext_variable, pad) #to return a plaintextmessage, we need the message (cyphertext message) and the pad
